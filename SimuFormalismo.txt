atomic Cinta(params) is (S , X , Y , δint, δext, λ, ta) where
params is
	L = 25;    //longitud de la cinta
	VC = 1;    //velocidad de los objetos
end params
------------------------------------------------------------------------------------------------------------------------
S is
	tipoCola ==List  (ℝ x Time);    //cola que guarda peso y tiempo de arribo de cada objeto
	cJ : tipoCola;       			//cola pc
	cPc : tipoCola;      			//cola jugador
	tiempo : Time; 					//tiempo de ejecucion
	σ : Time;        				//σ
end S
------------------------------------------------------------------------------------------------------------------------
X is
	input1 : ℝ; //LLega objeto de jugador
	input2 : ℝ; //LLega objeto de pc
end X
---------------------------------------------------------------------------------------------------------------------------
Y is
	Llegada == {LlegoJugador, LlegoPc};	
	Colision == {GanoJugador, GanoPc, Empate} x ℝ x ℝ;
	out1: Colision;
	out2: Llegada;   
end Y
---------------------------------------------------------------------------------------------------------------------------
δint((cJ, cPc, tiempo, σ)) is 
	defcases
		case
			tiempo = tiempo + σ;
			tupla :  ℝ x Time; 
      		tupla.1 = Libreria.pesoNuevo(cJ,cPc,tiempo);
      		tupla.2 = (head cJ).2;
      		cJ = (tail cJ)⁀tupla;
			cPc = (tail cPc);
			σ = Libreria.calcularσ(cJ,cPc,tiempo);
		if (#cJ>0 ∧ #cPc>0 ∧ Libreria.potencia(cJ,tiempo) > Libreria.potencia(cPc,tiempo))
		case
			tiempo = tiempo + σ;
			cJ = tail cJ;
			tupla :  ℝ x Time; 
      		tupla.1 = Libreria.pesoNuevo(cPc,cJ,tiempo);
      		tupla.2 = (head cpc).2;
      		cPc = (tail cPc)⁀tupla;
			σ = Libreria.calcularσ(cJ,cPc,tiempo);
		if (#cJ>0 ∧ #cPc>0 ∧ Libreria.potencia(cJ,tiempo) > Libreria.potencia(cPc,tiempo))
		case
			tiempo = tiempo + σ;
			cJ = tail cJ;
			cPc = tail cPc;
			σ = Libreria.calcularσ(cJ,cPc,tiempo);
		if (#cJ>0 ∧ #cPc>0 ∧ Libreria.potencia(cJ,tiempo) = Libreria.potencia(cPc,tiempo))
		case
			tiempo = tiempo + σ;
			cJ = tail cJ;
			cPc = cPc;
			σ = Libreria.calcularσ(cJ,cPc,tiempo);
		if (#cJ>0 ∧ #cPc=0)
		case
			tiempo = tiempo + σ;
			cJ = cJ;
			cPc = tail cPc;
			σ = Libreria.calcularσ(cJ,cPc,tiempo);
		if (#cJ=0 ∧ #cPc>0)
	end defcases
end δint
------
δext((cJ,cPc,tiempo,σ), e, (port, value)) is
	defcases
		case
			tiempo = tiempo + e;
			tupla :  ℝ x Time;
      		tupla.1 = value;
      		tupla.2 = tiempo;
			cJ= cJ⁀tupla;
			cPc = cPc;
			σ=calcularσ(cJ,cPc,tiempo);
		if (port=input1)
		case
			tiempo = tiempo + e;
			tupla :  ℝ x Time;
      		tupla.1 = value; 
      		tupla.2 = tiempo; 
			cJ= cJ;
			cPc = cPc⁀tupla;
			σ=calcularσ(cJ,cPc,tiempo);
		if (port=input2)
	end defcases
end δext
λ(cJ,cPc,tiempo,σ) is
	defcases
		case
			out1 = (GanoJugador, Libreria.pesoNuevo(cJ,cPc,tiempo+σ), Libreria.dist(cJ,tiempo+σ));
		if (¬(cJ={}) ∧ ¬(cPc={})∧ Libreria.potencia(cJ,tiempo+σ) > Libreria.potencia(cPc,tiempo+σ))
		case 
			out1 = (GanoPc, Libreria.pesoNuevo(cPc,cj,tiempo+σ), Libreria.dist(cPc,tiempo+σ)) 
		if (¬(cJ={}) ∧ ¬(cPc={}) ∧ Libreria.potencia(cJ,tiempo+σ) > Libreria.potencia(cPc,tiempo+σ))
		case
			out1 = (Empate, 0, 0);
		if (¬(cJ={}) ∧ ¬(cPc={}) ∧ Libreria.potencia(cJ,tiempo+σ) > Libreria.potencia(cPc,tiempo+σ))
		case
			out2 = LlegoJugador;
		if (¬(cJ={}) ∧ (cPc={}))
		case
			out2 = LlegoPc;
		if ((cJ={}) ∧ ¬(cPc={}))
	end defcases
end λ

ta(cJ,cPc,tiempo, σ) is
	σ;
end ta

end atomic

functions Libreria is

	// La funcion dist, devuelve la distancia que lleva recorrida el primer elemento de la cola
	// parametros: la cola y el tiempo actual
	
	function dist is
		cola : List (ℝ x Time) , tiempo: Time → res : ℝ;
		res = ((tiempo - (head c).2) * Vc);
	end dist

	// La funcion potencia devuelve la potencia de choque del objeto, valor utilizado para la comparacion ante una colision
	// parametros: la cola y el tiempo actual
	// retorna: La potencia del primer elemento de la cola
	
	function potencia is
		cola : List (ℝ x Time),tiempo:Time → res : ℝ;
		res = (head c).1 * Libreria.dist(cola,tiempo);
	end potencia
	
	
	// La funcion pesoNuevo devuelve el peso del elemento ganador de la colision, el cual sufre una reduccion de peso
	// parametros: la cola ganadora, la cola perdedora y el tiempo actual
	// retorna: El peso nuevo del primer objeto de la cola vencedora, luego de colisionar con el primer objeto de la cola perdedora
	
	function pesoNuevo
		colaVenc : List (ℝ x Time), r : colaPerd (ℝ x Time) ,tiempo:Time → res : ℝ;
		res = (head colaVenc).1 * (((head colaPerd).1 * Libreria.dist(colaPerd,tiempo) / ((head colaVenc).1 * Libreria.dist(colaVenc,tiempo)));
  	end pesoNuevo

	// La funcion calcularσ se encarga de calcular el tiempo hasta otro evento de la delta interna (colision o que un elemento llegue 
	// al final de la cinta)
	// parametros: la cola del jugador, la cola de la pc y el tiempo actual
	// retorna: el tiempo hasta una colision entre los primeros elemetos de las cintas o hasta que el primer elemento de alguna cola 
	// recorra toda la cinta
	
	
  	function calcularσ
  		colaJug : List (ℝ x Time), r : colaPc (ℝ x Time) ,tiempo:Time  → res : Time;
  		defcases
  			case
  				res=∞;
  			if ((colaJug={}) ∧ (colaPc={}))
  			case
  				res=(L - Libreria.dist(colaJug,tiempo) / VC);
  			if (¬(colaJug={}) ∧ (colaPc={}))
  			case
  				res=(L - Libreria.dist(colaJug,tiempo) / VC);
  			if ((colaJug={}) ∧ ¬(colaPc={}))
  			case
  				res=(L - (Libreria.dist(colaJug,tiempo) + Libreria.dist(colaPc,tiempo))) / (2*VC);
  			if (¬(colaJug={}) ∧ ¬(colaPc={}))



		end defcases
	end calcularσ
end Libreria









